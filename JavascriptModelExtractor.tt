<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Reflection" #>
<#@ output extension=".js" #>
<#@ assembly name="$(SolutionDir)../Libraries/Iris.Cross.Common.dll" #>

<#
//AppDomain domain = new AppDomain.CreateDomain("T4TransformAD");

//Assembly asm = Assembly.LoadFrom(@"D:\IrisCo\Widgets\DEVELOPMENT\SPRINT_23\Libraries\Iris.Models.dll");
//Assembly asm = Assembly.GetExecutingAssembly();
Assembly asm = typeof(Iris.Models.View).Assembly;
var types = asm.GetTypes().Where(w => !w.IsInterface && 
!w.Name.Contains("IrisScripts") && 
!w.Name.Contains("Exception") && 
!String.IsNullOrEmpty(w.Namespace) &&
!w.Name.Contains("Nexus") &&
!w.Name.Contains("Module") &&
!w.Name.Contains("Packet") &&
!w.Name.Contains("Alteryx") &&
!w.Name.Contains("Allocate") &&
!w.Name.Contains("Attribute") &&
!w.Name.Contains("WorkerConfiguration") &&
!w.Name.Contains("HubConfiguration") &&
!w.Name.StartsWith("Asset")).ToList();

types = types.Where(w => !w.Namespace.Contains("Autogen") && !w.Namespace.Contains("Delegates")).ToList();

types = types.OrderBy(o => o.Name).ToList();

string javascriptNamespaceRoot = "Iris";

#>

var <#= javascriptNamespaceRoot #> = <#= javascriptNamespaceRoot #> || {};
<#= javascriptNamespaceRoot #>.Models = <#= javascriptNamespaceRoot #>.Models || {};
<#= javascriptNamespaceRoot #>.Enums = <#= javascriptNamespaceRoot #>.Enums || {};

<#= javascriptNamespaceRoot #>.Models.IrisEnumType = function (names, values) {
    this.Names = names;
    this.Values = values;
};
<#= javascriptNamespaceRoot #>.Models.IrisEnumType.prototype.GetValue = function (name) {
    var length = this.Names.length;
    for (var i = length - 1; i >= 0; i--) {
        if (this.Names[i] === name) {
            return this.Values[i];
        }
    }

    return null;
};
<#= javascriptNamespaceRoot #>.Models.IrisEnumType.prototype.GetName = function (value) {
    var length = this.Values.length;
    for (var i = length - 1; i >= 0; i--) {
        if (this.Values[i] === value) {
            return this.Names[i];
        }
    }

    return null;
};
<#= javascriptNamespaceRoot #>.Models.IrisEnumType.prototype.GetDefaultValue = function () {
    return this.Values[0];
};
<#= javascriptNamespaceRoot #>.Models.IrisEnumType.prototype.GetDefaultName = function () {
    return this.Names[0];
};


<# 

    List<Type> EnumTypes = (from type in types where type.IsEnum select type).ToList();
    List<Type> NonEnumTypes = (from type in types where !type.IsEnum select type).ToList();

    foreach (Type type in EnumTypes)
    {
        string enumTypeName = type.Name;

        string[] enumNames = Enum.GetNames(type);
        Array enumValues = Enum.GetValues(type);

        int nameCount = enumNames.Length;
        int valueCount = enumValues.Length;

#>

/***********************************************
* Name : <#= javascriptNamespaceRoot #>.Enums.<#= enumTypeName #>
* Description: This enumeration was autogenerated. Any modifications could be
* lost upon model regeneration
* Last Updated: <#=  DateTime.Now #>
************************************************/
<#= javascriptNamespaceRoot #>.Enums.<#= enumTypeName #> = new <#= javascriptNamespaceRoot #>.Models.IrisEnumType(
    // Names
    [
<#
        int index = 0;
        foreach (string name in enumNames)
        {
            string commaValue = index == nameCount - 1 ? "": ",";
#>
        '<#= name #>'<#= commaValue #>
<#
            ++index;
        }

#>
    ],
    // Values
    [
<#
        index = 0;
        foreach (var item in enumValues)
        {
            int enumValue = (int)item;
            string commaValue = index == valueCount - 1 ? "": ",";
#>
        <#= enumValue #><#= commaValue #>
<#
            ++index;
        }

#>
    ]
);
<#


    }

foreach(var type in NonEnumTypes) { 
	bool skip = ShouldSkipClass(type.Name);

	if(skip)
	{
		continue;
	}

        bool classIsGeneric = type.IsGenericType;
        Type[] genericTypeArgs = type.GenericTypeArguments;

    string typeName;
    if (type.Name.Contains("`"))
    {
        typeName = type.Name.Substring(0, type.Name.IndexOf("`"));
    }
    else
    {
        typeName = type.Name;
    }
#>
/***********************************************
* Name : <#= javascriptNamespaceRoot #>.Models.<#= typeName #>
* Description: This class was autogenerated. Any modifications could be lost upon 
*  model regeneration
* Last Updated: <#= DateTime.Now #>
************************************************/
<#= javascriptNamespaceRoot #>.Models.<#= typeName #> = function () {

	//--begin server entity population
<#        	
	var members = type.GetProperties();
	foreach(var mem in members)
	{

        // Don't include static properties
        MethodInfo methodInfo = mem.GetGetMethod();
        if (methodInfo != null && methodInfo.IsStatic)
        {
            continue;
        }

		var formattedName = mem.Name;
				
		string propType = mem.PropertyType.Name;
		if(IsNumericType(propType))
        {
		#>    this.<#= formattedName #> = 0; <#
        }                
        else if(propType == "String")
        {
		#>    this.<#= formattedName #> = ""; <#
        }
		else if(propType == "Boolean")
		{
		#>    this.<#= formattedName #> = false; <#
		}
		else if(propType == "DateTime")
		{
		#>    this.<#= formattedName #> = new Date(); <#
		}
        else if(propType.Contains("Nullable"))
        {
		#>    this.<#= formattedName #> = null; <#
        }
		else if(propType.EndsWith("[]") || propType.StartsWith("List`"))
		{
		#>    this.<#= formattedName #> = []; <#
		}
        else if(propType == "T")
        {
			#>    this.<#= formattedName #> = null; <#
        }
		else if(mem.PropertyType.IsEnum)
		{
		#>    this.<#= formattedName #> = <#= javascriptNamespaceRoot #>.Enums.<#= mem.PropertyType.Name #>.GetDefaultValue(); //enum<#
		}
        else
        {
            //object
			#>    this.<#= formattedName #> = null; <#
        }
		#>	
<#	
	}
#>	
    //--This is where all client state data should exist
   	this.ClientState = {}; 
}; //end function

/***********************************************
* Name : setJSON
* Args : data = json object from server
************************************************/
<#= javascriptNamespaceRoot #>.Models.<#= typeName #>.prototype.setJSON = function (data) {
    if (!data) return null;

<#        		
        int currentIterator = 0;
		foreach(var mem in members)
		{
            Type propertyType = mem.PropertyType;
			string formattedName = mem.Name;		
            string rawPropTypeName = propertyType.Name;
            string propTypeName = rawPropTypeName;


            // Enum

            if (propertyType.IsEnum)
            {
#>
    this.<#= formattedName #> = data.<#= formattedName #>;
<#
                continue;
            }


            // Non-Enum

            string i = String.Format("i{0}", currentIterator);
            string j = String.Format("j{0}", currentIterator);

            string row = String.Format("row{0}", currentIterator);
            string item = String.Format("item{0}", currentIterator);

            string length = String.Format("length{0}", currentIterator);
            string sublength = String.Format("sublength{0}", currentIterator);

            bool isNullable = false;
            bool isList = rawPropTypeName.StartsWith("List`");
            bool isArray = rawPropTypeName.EndsWith("[]");
            bool isEnumerable = isList || isArray;

            if (isList)
            {
                Type[] genericListTypes = propertyType.GenericTypeArguments;
                propertyType = genericListTypes[0];
                propTypeName = propertyType.Name;
            }
            else if (isArray)
            {
                propTypeName = rawPropTypeName.Substring(0, rawPropTypeName.Length - 2);
            }

            bool isSubNullable = false;
            bool isSubList = propTypeName.StartsWith("List`");
            bool isSubArray = propTypeName.EndsWith("[]");
            bool isSubEnumerable = isSubList || isSubArray;

            if (isSubList)
            {
                Type[] genericListTypes = propertyType.GenericTypeArguments;
                propertyType = genericListTypes[0];
                propTypeName = propertyType.Name;
            }
            else if (isSubArray)
            {
                propTypeName = propTypeName.Replace("[]", "");
            }

            isNullable = propTypeName.StartsWith("Nullable`");
            if (isNullable)
            {
                Type[] genericNullableTypes = propertyType.GenericTypeArguments;
                propTypeName = genericNullableTypes[0].Name;
            }

            bool isPrimitiveType = IsPrimitiveType(propTypeName);

            if (isSubEnumerable)
            {
                if (isPrimitiveType || 
                propTypeName == "DateTime" || 
                rawPropTypeName.Contains("Dictionary") || 
                IsGenericPropertyType(propertyType) ||
                propTypeName.Contains("IGeometry") || 
                propTypeName.Contains("SpatialObject"))
                {

            // List or Array of Primitives
#>

    this.<#= formattedName #> = [];
    var <#= length #> = data.<#= formattedName #>.length;
    for (var <#= i #> = 0; <#= i #> < <#= length #>; <#= i #>++) {
        var <#= row #> = [];
        var <#= sublength #> = data.<#= formattedName #>[<#= i #>].length;
        for (var <#= j #> = 0; <#= j #> < <#= sublength #>; <#= j #>++) {
            <#= row #>.push(data.<#= formattedName #>[<#= i #>][<#= j #>]);
        }

        this.<#= formattedName #>.push(<#= row #>);
    }
<#
                }
                else
                {

            // List or Array of Iris Types
#>

    this.<#= formattedName #> = [];
    if (data.<#= formattedName #> && data.<#= formattedName #>.length) {
        if (<#= javascriptNamespaceRoot #>.Models.<#= propTypeName #>) {
            var <#= length #> = data.<#= formattedName #>.length;
            for (var <#= i #> = 0; <#= i #> < <#= length #>; <#= i #>++) {
                var <#= row #> = [];
                var <#= sublength #> = data.<#= formattedName #>[<#= i #>].length;
                for (var <#= j #> = 0; <#= j #> < <#= sublength #>; <#= j #>++) {
                    var <#= item #><#= formattedName #> = new <#= javascriptNamespaceRoot #>.Models.<#= propTypeName #>();
                    <#= item #>.setJSON(data.<#= formattedName #>[<#= i #>]);
                    <#= row #>.push(<#= item #>);
                }

                this.<#= formattedName #>.push(<#= row #>);
            }
        }
        else {
            this.<#= formattedName #> = data.<#= formattedName #>;
        }
    }
<#

                }

                ++currentIterator;
            }
            else if (isEnumerable)
            {
                if (isPrimitiveType || 
                propTypeName == "DateTime" || 
                rawPropTypeName.Contains("Dictionary") || 
                IsGenericPropertyType(propertyType) ||
                propTypeName.Contains("IGeometry") || 
                propTypeName.Contains("SpatialObject"))
                {

            // List or Array of Primitives
#>

    this.<#= formattedName #> = [];
    if (data.<#= formattedName #> && data.<#= formattedName #>.length) {
        var <#= length #> = data.<#= formattedName #>.length;
        for (var <#= i #> = 0; <#= i #> < <#= length #>; <#= i #>++) {
            this.<#= formattedName #>.push(data.<#= formattedName #>[<#= i #>]);
        }
    }
<#
                }
                else
                {

            // List or Array of Iris Types
#>

    this.<#= formattedName #> = [];
    if (data.<#= formattedName #> && data.<#= formattedName #>.length) {
        if (<#= javascriptNamespaceRoot #>.Models.<#= propTypeName #>) {
            var <#= length #> = data.<#= formattedName #>.length;
            for (var <#= i #> = 0; <#= i #> < <#= length #>; <#= i #>++) {
                var <#= item #> = new <#= javascriptNamespaceRoot #>.Models.<#= propTypeName #>();
                <#= item #>.setJSON(data.<#= formattedName #>[<#= i #>]);
                this.<#= formattedName #>.push(<#= item #>);
            }
        }
        else {
            this.<#= formattedName #> = data.<#= formattedName #>;
        }
    }
<#

                }

                ++currentIterator;
            }
            else
            {
                if (isPrimitiveType || 
                propTypeName == "DateTime" || 
                rawPropTypeName.Contains("Dictionary") || 
                IsGenericPropertyType(propertyType) ||
                propTypeName.Contains("IGeometry") || 
                propTypeName.Contains("SpatialObject"))
                {

            // Single Primitive Type
#>
    this.<#= formattedName #> = data.<#= formattedName #>;
<#
                }
                else
                {

            // Single Iris Type
#>

    if (data.<#= formattedName #>) {
        if (<#= javascriptNamespaceRoot #>.Models.<#= propTypeName #>) {
            this.<#= formattedName #> = new <#= javascriptNamespaceRoot #>.Models.<#= propTypeName #>();
            this.<#= formattedName #>.setJSON(data.<#= formattedName #>);
        }
        else {
            this.<#= formattedName #> = data.<#= formattedName #>;
        }
    }
    else {
        this.<#= formattedName #> = null;
    }

<#
                }

            }
        }
		#>};    

/***********************************************
* Name : toEntity
* Args : data = json object from server
************************************************/
<#= javascriptNamespaceRoot #>.Models.<#= typeName #>.prototype.toEntity = function () {

    return { <#        	

    int memberCount = members.Length - 1;
	foreach(var mem in members)
	{

        // Don't include static properties
        MethodInfo methodInfo = mem.GetGetMethod();
        if (methodInfo != null && methodInfo.IsStatic)
        {
            continue;
        }

        string comma = memberCount-- > 0 ? "," : "";

            //object
			#>

        <#= mem.Name #>: this.<#= mem.Name #><#= comma #> <#
	}
#>	
    };
};

<# 
		//} //end if
	} //end foreach
#>

<#+
    private bool ShouldSkipClass(string name)
    {	

        List<string> excludes = new List<string>();
        excludes.Add("WidgetsAnalyticData");

        foreach(string item in excludes)
        {
            if(item.ToUpper().Trim() == name.ToUpper().Trim()){
                return true;
            }
        }

        return false;
    }

    private bool IsPrimitiveEnumerable(string propType)
    {
        if (!propType.Contains("[]") && !propType.Contains("List"))
        {
            return false;
        }

        string arrayTypeName = propType.Replace("[]", "");

        string listTypeName = propType.Replace("List<", "");
        listTypeName = propType.Replace(">", "");

        if (PrimitiveTypes.Contains(arrayTypeName))
        {
            return true;
        }

        if (PrimitiveTypes.Contains(listTypeName))
        {
            return true;
        }

        return false;
    }

    private bool IsNonPrimitiveEnumerable(string propType)
    {
        if (IsPrimitiveEnumerable(propType))
        {
            return false;
        }

        return propType.Contains("[]") || propType.Contains("List`") || propType.Contains("List<");
    }

    private List<string> PrimitiveTypes = new List<string>()
    {
        "String",
        "Int16",
        "Int32",
        "Int64",
        "UInt16",
        "UInt32",
        "UInt64",
        "Double",
        "Decimal",
        "object",
        "Object",
        "Boolean",
        "UShort",
        "ushort"
    };

    private List<string> NumericTypes= new List<string>()
    {
        "Int16",
        "Int32",
        "Int64",
        "UInt16",
        "UInt32",
        "UInt64",
        "Double",
        "Decimal",
    };

    private bool IsPrimitiveType(string cSharpType)
    {
        return PrimitiveTypes.Contains(cSharpType);
    }

    private bool IsNumericType(string cSharpType)
    {
        return NumericTypes.Contains(cSharpType);
    }

    private bool IsGenericPropertyType(Type type)
    {
        try
        {
            int position = type.GenericParameterPosition;
            return true;
        }
        catch
        {
            return false;
        }

    }

    private Type GetGenericActualType(Type classType, Type propertyType)
    {
        try
        {
            int position = propertyType.GenericParameterPosition;
            Type type = classType.GenericTypeArguments[position];
            return type;
        }
        catch
        {
            return null;
        }

    }

#>